import json
import os
import asyncio
import logging
import time
from datetime import datetime
from typing import Optional, Tuple, Dict, Tuple as Tup
from telegram import Bot
from telegram.error import Forbidden, BadRequest, TimedOut, NetworkError

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–µ—Ä–∞ ‚Äî —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω —Å –æ—Å–Ω–æ–≤–Ω—ã–º –±–æ—Ç–æ–º
logger = logging.getLogger('database')
logger.setLevel(logging.WARNING)
if not logger.handlers:
    handler = logging.FileHandler('logs/database_errors.log', encoding='utf-8')
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

# –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–ª—è —Ñ–∞–π–ª–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
file_lock = asyncio.Lock()

DATA_DIR = 'data'
CREDITS_FILE = os.path.join(DATA_DIR, 'user_credits.json')  # –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
BANNED_FILE = os.path.join(DATA_DIR, 'banned_users.txt')
RATE_FILE = os.path.join(DATA_DIR, 'rate_limits.json')     # —Ç–æ–∫–µ–Ω-–±–∞–∫–µ—Ç

def ensure_data_files():
    """–°–æ–∑–¥–∞–µ—Ç –≤—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ñ–∞–π–ª—ã –¥–∞–Ω–Ω—ã—Ö –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç"""
    os.makedirs(DATA_DIR, exist_ok=True)

    if not os.path.exists(CREDITS_FILE):
        try:
            with open(CREDITS_FILE, 'w', encoding='utf-8') as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.warning(f"Init file error {CREDITS_FILE}: {e}")

    if not os.path.exists(BANNED_FILE):
        try:
            with open(BANNED_FILE, 'w', encoding='utf-8') as f:
                pass
        except Exception as e:
            logger.warning(f"Init file error {BANNED_FILE}: {e}")

    if not os.path.exists(RATE_FILE):
        try:
            with open(RATE_FILE, 'w', encoding='utf-8') as f:
                json.dump({}, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.warning(f"Init file error {RATE_FILE}: {e}")

def init_user_data():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    ensure_data_files()
    logger.info("üìÅ Data files initialized")

async def load_json_data(filename: str, default=None):
    try:
        ensure_data_files()
        async with file_lock:
            if os.path.exists(filename) and os.path.getsize(filename) > 0:
                with open(filename, 'r', encoding='utf-8') as f:
                    return json.load(f)
    except (json.JSONDecodeError, Exception) as e:
        logger.warning(f"Load error {filename}: {e}")
        async with file_lock:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(default or {}, f, ensure_ascii=False, indent=2)
    return default or {}

async def save_json_data(filename: str, data):
    try:
        ensure_data_files()
        async with file_lock:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.warning(f"Save error {filename}: {e}")

# --- –ö—Ä–µ–¥–∏—Ç—ã (–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Ä–∞–Ω–Ω–∏–º–∏ –≤–µ—Ä—Å–∏—è–º–∏) ---
def get_user_credits(user_id: int) -> int:
    """–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ –∫—Ä–µ–¥–∏—Ç—ã (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –±–æ—Ç–æ–º)."""
    ensure_data_files()
    try:
        with open(CREDITS_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        data = {}
    return int(data.get(str(user_id), {}).get("credits", 999999))

def update_user_credits(user_id: int, credits: int):
    """–°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å: –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç, –Ω–æ –±–æ—Ç –ª–∏–º–∏—Ç—ã –±–æ–ª—å—à–µ –Ω–µ —á–∏—Ç–∞–µ—Ç –∏–∑ –∫—Ä–µ–¥–∏—Ç–æ–≤."""
    ensure_data_files()
    try:
        with open(CREDITS_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        data = {}
    data[str(user_id)] = {"credits": max(0, int(credits)), "last_reset": datetime.now().isoformat()}
    try:
        with open(CREDITS_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.warning(f"Update credits error: {e}")

# --- –ë–∞–Ω-–ª–∏—Å—Ç ---
def is_user_banned(user_id: int) -> bool:
    ensure_data_files()
    try:
        with open(BANNED_FILE, 'r', encoding='utf-8') as f:
            banned_users = [line.strip() for line in f if line.strip()]
            return str(user_id) in banned_users
    except Exception as e:
        logger.warning(f"Banned check error: {e}")
    return False

def add_banned_user(user_id: int):
    ensure_data_files()
    try:
        with open(BANNED_FILE, 'a', encoding='utf-8') as f:
            f.write(f"{user_id}\n")
    except Exception as e:
        logger.warning(f"Ban error: {e}")

# --- –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏ ‚Äî –∫—ç—à —Å TTL ---
ALLOWED_STATUSES = {'member', 'administrator', 'creator', 'restricted'}

def _env_flag(name: str, default: bool = False) -> bool:
    v = os.getenv(name, str(default)).strip().lower()
    return v in ('1', 'true', 'yes', 'y', 'on')

FAIL_OPEN = _env_flag('SUBSCRIPTION_FAIL_OPEN', False)
SUB_CACHE_TTL = int(os.getenv('SUBSCRIPTION_CACHE_TTL', '600'))  # —Å–µ–∫, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10 –º–∏–Ω—É—Ç

# (user_id, chat_id) -> (status_bool, timestamp)
_SUB_CACHE: Dict[Tup[int, int], Tup[bool, float]] = {}
# –∫—ç—à –¥–ª—è —Ä–µ–∑–æ–ª–≤–∏–Ω–≥–∞ @username -> chat_id
_CHAT_RESOLVE_CACHE: Dict[str, int] = {}

async def _resolve_chat_id(bot: Bot, channel_id) -> Optional[int]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —á–∏—Å–ª–æ–≤–æ–π chat_id –ø–æ @username –∏–ª–∏ —á–∏—Å–ª—É; None –ø—Ä–∏ –æ—à–∏–±–∫–µ."""
    try:
        if isinstance(channel_id, str) and channel_id.startswith('@'):
            # –∫—ç—à–∏—Ä—É–µ–º —Ä–µ–∑–æ–ª–≤
            if channel_id in _CHAT_RESOLVE_CACHE:
                return _CHAT_RESOLVE_CACHE[channel_id]
            chat = await bot.get_chat(channel_id)
            _CHAT_RESOLVE_CACHE[channel_id] = chat.id
            return chat.id
        if isinstance(channel_id, str):
            channel_id = int(channel_id)
        return int(channel_id)
    except Exception as e:
        logger.warning(f"resolve chat_id failed for {channel_id}: {type(e).__name__}: {e}")
        return None

def _cache_get(user_id: int, chat_id: int) -> Optional[bool]:
    key = (user_id, chat_id)
    item = _SUB_CACHE.get(key)
    if not item:
        return None
    status, ts = item
    if time.time() - ts <= SUB_CACHE_TTL:
        return status
    # –ø—Ä–æ—Å—Ä–æ—á–µ–Ω
    _SUB_CACHE.pop(key, None)
    return None

def _cache_set(user_id: int, chat_id: int, status: bool):
    _SUB_CACHE[(user_id, chat_id)] = (status, time.time())

async def check_subscription(user_id: int, channel_id, bot: Bot) -> bool:
    """
    True, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –∫–∞–Ω–∞–ª.
    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç channel_id –∫–∞–∫ '-100‚Ä¶' —Ç–∞–∫ –∏ '@username'.
    –ö—ç—à–∏—Ä—É–µ—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç–∞—Ç—É—Å—ã –Ω–∞ SUBSCRIPTION_CACHE_TTL (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 10 –º–∏–Ω—É—Ç).
    –ï—Å–ª–∏ —Ä–∞–Ω–µ–µ –±—ã–ª–æ False –∏–ª–∏ –∫—ç—à –∏—Å—Ç—ë–∫ ‚Äî –¥–µ–ª–∞–µ–º –∂–∏–≤—É—é –ø—Ä–æ–≤–µ—Ä–∫—É.
    """
    chat_id = await _resolve_chat_id(bot, channel_id)
    if chat_id is None:
        # –ö–æ–Ω—Ñ–∏–≥ –±–∏—Ç—ã–π ‚Äî –ø—Ä–∏ FAIL_OPEN=True –Ω–µ –ª–æ–º–∞–µ–º UX
        return True if FAIL_OPEN else False

    # 1) –±—ã—Å—Ç—Ä—ã–π —Ö–∏—Ç –∏–∑ –∫—ç—à–∞: –µ—Å–ª–∏ True ‚Äî —Å—Ä–∞–∑—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º
    cached = _cache_get(user_id, chat_id)
    if cached is True:
        return True
    # –ï—Å–ª–∏ cached False/None ‚Äî –∏–¥—ë–º –≤ Telegram

    try:
        member = await bot.get_chat_member(chat_id=chat_id, user_id=user_id)
        ok = getattr(member, "status", None) in ALLOWED_STATUSES
        _cache_set(user_id, chat_id, ok)
        return ok

    except Forbidden as e:
        logger.warning(f"check_subscription Forbidden for {chat_id}: {e}")
        return True if FAIL_OPEN else False

    except (TimedOut, NetworkError) as e:
        logger.warning(f"check_subscription network issue: {type(e).__name__}: {e}")
        return True if FAIL_OPEN else False

    except BadRequest as e:
        logger.warning(f"check_subscription BadRequest for {chat_id}: {e}")
        return False

    except Exception as e:
        logger.warning(f"check_subscription unexpected {type(e).__name__}: {e}")
        return False

# --- Token Bucket per user (–ø–µ—Ä—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ã–π) ---
def _load_rate_state() -> dict:
    ensure_data_files()
    try:
        with open(RATE_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return {}

def _save_rate_state(state: dict):
    ensure_data_files()
    try:
        with open(RATE_FILE, 'w', encoding='utf-8') as f:
            json.dump(state, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.warning(f"Save error {RATE_FILE}: {e}")

def allow_request_token_bucket(
    user_id: int,
    capacity: float = 30.0,          # burst: —Å–∫–æ–ª—å–∫–æ –º–æ–∂–Ω–æ ¬´–∑–∞–ª–∏—Ç—å¬ª –ø–æ–¥—Ä—è–¥
    refill_per_sec: float = 0.5,     # —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è: —Ç–æ–∫–µ–Ω–æ–≤/—Å–µ–∫ (‚âà 30 —Ç–æ–∫/–º–∏–Ω)
    cost: float = 1.0
) -> Tuple[bool, float]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (allowed, wait_seconds).
    –ï—Å–ª–∏ allowed=False ‚Äî —á–µ—Ä–µ–∑ —Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è —Å–Ω–æ–≤–∞.
    –•—Ä–∞–Ω–∏—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ data/rate_limits.json.
    """
    state = _load_rate_state()
    user_key = str(user_id)
    now = time.time()

    user_state = state.get(user_key, {"tokens": capacity, "updated": now})
    tokens = float(user_state.get("tokens", capacity))
    updated = float(user_state.get("updated", now))

    # –ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ
    delta = max(0.0, now - updated)
    tokens = min(capacity, tokens + delta * refill_per_sec)

    if tokens >= cost:
        tokens -= cost
        state[user_key] = {"tokens": tokens, "updated": now}
        _save_rate_state(state)
        return True, 0.0
    else:
        deficit = cost - tokens
        wait = deficit / refill_per_sec if refill_per_sec > 0 else 5.0
        state[user_key] = {"tokens": tokens, "updated": now}
        _save_rate_state(state)
        return False, wait
